{"name":"Sky11","tagline":"tengine health check","body":"`tengine的健康检查模块的解析：`\r\n\r\n基本原理：\r\n===\r\n\r\n　　其实基本思想都是一样定期的和后端机器进行测试连接然后进行更新相应的状态，然后都有机器选择后端的时候然后会\r\n判断其状态进行选取评估．    \r\n　　特点是：该模块使得每一个后端peer都携带一个自检测事件，按照其配置的interval进行测试后端然后进行修改相应的状态．\r\n而且同一时刻只让一个进程进行检测．其锁的粒度很小，控制在每一个后端peer的数据单元上．     \r\n\r\n```nginx\r\nhttp {\r\n    upstream bar {\r\n        server 127.0.0.1:81;\r\n        server 127.0.0.1:82;\r\n        check interval=3000 rise=2 fall=5 timeout=1000 type=http;\r\n        check_keepalive_requests 100;\r\n        check_http_send \"HEAD / HTTP/1.1\\r\\nConnection: keep-alive\\r\\n\\r\\n\";\r\n        check_http_expect_alive http_2xx http_3xx;\r\n    }\r\n\r\n    server {\r\n        listen 80;\r\n        location /t{\r\n            proxy_pass http://bar;\r\n        }\r\n\r\n        location /status {\r\n            check_status;\r\n            access_log  off;\r\n            allow 127.0.0.1;\r\n            deny all;\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n相关参数的解释：    \r\n===\r\n注意单位是毫秒．\r\n\r\n* interval：向后端发送的健康检查包的间隔。   \r\n* fall(fall_count): 如果连续失败次数达到fall_count，服务器就被认为是down。   \r\n* rise(rise_count): 如果连续成功次数达到rise_count，服务器就被认为是up。      \r\ntimeout: 后端健康请求的超时时间。    \r\n* default_down: 设定初始时服务器的状态，如果是true，就说明默认是down的，如果是false，就是up的。其默认值是true，\r\n也就是一开始服务器认为是不可用，要等健康检查包达到一定成功次数以后才会被认为是健康的。    \r\n* type：健康检查包的类型，如http,tcp等    \r\n\r\n相关代码解析：　　\r\n====\r\n\r\n在init_perocess阶段为每一个worker进程进行设置相应的事件定时器．其在每一个worker进程都会生效\r\n\r\n```c  \r\nstatic ngx_int_t\r\nngx_http_upstream_check_add_timers(ngx_cycle_t *cycle)\r\n{\r\n    ngx_uint_t                           i;\r\n    ngx_msec_t                           t, delay;\r\n    ngx_check_conf_t                    *cf;\r\n    ngx_http_upstream_check_peer_t      *peer;\r\n    ngx_http_upstream_check_peers_t     *peers;\r\n    ngx_http_upstream_check_srv_conf_t  *ucscf;\r\n    ngx_http_upstream_check_peer_shm_t  *peer_shm;\r\n    ngx_http_upstream_check_peers_shm_t *peers_shm;\r\n\r\n    peers = check_peers_ctx;\r\n    if (peers == NULL) {\r\n        return NGX_OK;\r\n    }\r\n\r\n    peers_shm = peers->peers_shm;\r\n    if (peers_shm == NULL) {\r\n        return NGX_OK;\r\n    }\r\n\r\n    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, cycle->log, 0,\r\n                   \"http check upstream init_process, shm_name: %V, \"\r\n                   \"peer number: %ud\",\r\n                   &peers->check_shm_name,\r\n                   peers->peers.nelts);\r\n\r\n    srandom(ngx_pid);\r\n\r\n    peer = peers->peers.elts;\r\n    peer_shm = peers_shm->peers;\r\n　　　　//为每一个后端peer都进行设置相应的检测时间\r\n    for (i = 0; i < peers->peers.nelts; i++) {\r\n        peer[i].shm = &peer_shm[i];\r\n\r\n        peer[i].check_ev.handler = ngx_http_upstream_check_begin_handler;\r\n        peer[i].check_ev.log = cycle->log;\r\n        peer[i].check_ev.data = &peer[i];\r\n        peer[i].check_ev.timer_set = 0;\r\n\r\n        peer[i].check_timeout_ev.handler =\r\n            ngx_http_upstream_check_timeout_handler;\r\n        peer[i].check_timeout_ev.log = cycle->log;\r\n        peer[i].check_timeout_ev.data = &peer[i];\r\n        peer[i].check_timeout_ev.timer_set = 0;\r\n\r\n        ucscf = peer[i].conf;\r\n        cf = ucscf->check_type_conf;\r\n\r\n        if (cf->need_pool) {\r\n            peer[i].pool = ngx_create_pool(ngx_pagesize, cycle->log);\r\n            if (peer[i].pool == NULL) {\r\n                return NGX_ERROR;\r\n            }\r\n        }\r\n\r\n        peer[i].send_handler = cf->send_handler;\r\n        peer[i].recv_handler = cf->recv_handler;\r\n\r\n        peer[i].init = cf->init;\r\n        peer[i].parse = cf->parse;\r\n        peer[i].reinit = cf->reinit;\r\n\r\n        /*\r\n         * We add a random start time here, since we don't want to trigger\r\n         * the check events too close to each other at the beginning.\r\n         */\r\n        delay = ucscf->check_interval > 1000 ? ucscf->check_interval : 1000;\r\n        t = ngx_random() % delay;\r\n\r\n        ngx_add_timer(&peer[i].check_ev, t);\r\n    }\r\n\r\n    return NGX_OK;\r\n}\r\n```\r\n\r\n每个peer进行设置的自测连接事件\r\n```c  \r\nstatic void\r\nngx_http_upstream_check_begin_handler(ngx_event_t *event)\r\n{\r\n    ngx_msec_t                           interval;\r\n    ngx_http_upstream_check_peer_t      *peer;\r\n    ngx_http_upstream_check_peers_t     *peers;\r\n    ngx_http_upstream_check_srv_conf_t  *ucscf;\r\n    ngx_http_upstream_check_peers_shm_t *peers_shm;\r\n\r\n    if (ngx_http_upstream_check_need_exit()) {\r\n        return;\r\n    }\r\n\r\n    peers = check_peers_ctx;\r\n    if (peers == NULL) {\r\n        return;\r\n    }\r\n\r\n    peers_shm = peers->peers_shm;\r\n    if (peers_shm == NULL) {\r\n        return;\r\n    }\r\n\r\n    peer = event->data;\r\n    ucscf = peer->conf;\r\n　　　　//由于定时时间一旦发生就会从注册的地方进行删除，为了下次继续定时　所以递归进行定时\r\n    ngx_add_timer(event, ucscf->check_interval / 2);\r\n\r\n    /* This process is processing this peer now. */\r\n    if (peer->shm->owner == ngx_pid ||\r\n        peer->check_timeout_ev.timer_set) {\r\n        return;\r\n    }\r\n\r\n    interval = ngx_current_msec - peer->shm->access_time;\r\n    ngx_log_debug5(NGX_LOG_DEBUG_HTTP, event->log, 0,\r\n                   \"http check begin handler index: %ui, owner: %P, \"\r\n                   \"ngx_pid: %P, interval: %M, check_interval: %M\",\r\n                   peer->index, peer->shm->owner,\r\n                   ngx_pid, interval,\r\n                   ucscf->check_interval);\r\n　　　　//进行抢锁，此锁是一个自旋锁\r\n    ngx_shmtx_lock(&peer->shm->mutex);\r\n\r\n    if (peers_shm->generation != ngx_http_upstream_check_shm_generation) {\r\n        ngx_shmtx_unlock(&peer->shm->mutex);\r\n        return;\r\n    }\r\n    //判断时间间隔\r\n    if ((interval >= ucscf->check_interval)\r\n         && (peer->shm->owner == NGX_INVALID_PID))\r\n    {\r\n        peer->shm->owner = ngx_pid;\r\n\r\n    } else if (interval >= (ucscf->check_interval << 4)) {\r\n\r\n        /*\r\n         * If the check peer has been untouched for 2^4 times of\r\n         * the check interval, activate the current timer.\r\n         * Sometimes, the checking process may disappear\r\n         * in some circumstances, and the clean event will never\r\n         * be triggered.\r\n         */\r\n        peer->shm->owner = ngx_pid;\r\n        peer->shm->access_time = ngx_current_msec;\r\n    }\r\n\r\n    ngx_shmtx_unlock(&peer->shm->mutex);\r\n　　　　//只让当前抢到锁的进程进行连接处理后端\r\n    if (peer->shm->owner == ngx_pid) {\r\n        ngx_http_upstream_check_connect_handler(event);\r\n    }\r\n}\r\n```\r\n\r\n进行测试连接后端\r\n```c\r\nstatic void\r\nngx_http_upstream_check_connect_handler(ngx_event_t *event)\r\n{\r\n    ngx_int_t                            rc;\r\n    ngx_connection_t                    *c;\r\n    ngx_http_upstream_check_peer_t      *peer;\r\n    ngx_http_upstream_check_srv_conf_t  *ucscf;\r\n　　　　//判断当是不是要结束进程\r\n    if (ngx_http_upstream_check_need_exit()) {\r\n        return;\r\n    }\r\n\r\n    peer = event->data;\r\n    ucscf = peer->conf;\r\n　　　　//判断其连接是不是空空\r\n    if (peer->pc.connection != NULL) {\r\n        c = peer->pc.connection;\r\n　　　　　　　　//测试该连接是否还可以复用　可以复用\r\n        if ((rc = ngx_http_upstream_check_peek_one_byte(c)) == NGX_OK) {\r\n            goto upstream_check_connect_done;\r\n        } else {\r\n            ngx_close_connection(c);\r\n            peer->pc.connection = NULL;\r\n        }\r\n    }\r\n    ngx_memzero(&peer->pc, sizeof(ngx_peer_connection_t));\r\n\r\n    peer->pc.sockaddr = peer->check_peer_addr->sockaddr;\r\n    peer->pc.socklen = peer->check_peer_addr->socklen;\r\n    peer->pc.name = &peer->check_peer_addr->name;\r\n\r\n    peer->pc.get = ngx_event_get_peer;\r\n    peer->pc.log = event->log;\r\n    peer->pc.log_error = NGX_ERROR_ERR;\r\n\r\n    peer->pc.cached = 0;\r\n    peer->pc.connection = NULL;\r\n　　　　//若该连接已经断开了　则进行重新进行连接\r\n    rc = ngx_event_connect_peer(&peer->pc);\r\n\r\n    if (rc == NGX_ERROR || rc == NGX_DECLINED) {\r\n        ngx_http_upstream_check_status_update(peer, 0);\r\n        return;\r\n    }\r\n\r\n    /* NGX_OK or NGX_AGAIN */\r\n    c = peer->pc.connection;\r\n    c->data = peer;\r\n    c->log = peer->pc.log;\r\n    c->sendfile = 0;\r\n    c->read->log = c->log;\r\n    c->write->log = c->log;\r\n    c->pool = peer->pool;\r\n\r\nupstream_check_connect_done:\r\n    peer->state = NGX_HTTP_CHECK_CONNECT_DONE;\r\n\r\n    c->write->handler = peer->send_handler;\r\n    c->read->handler = peer->recv_handler;\r\n\r\n    ngx_add_timer(&peer->check_timeout_ev, ucscf->check_timeout);\r\n\r\n    /* The kqueue's loop interface needs it. */\r\n    if (rc == NGX_OK) {\r\n        c->write->handler(c->write);\r\n    }\r\n} peer->pc.log_error = NGX_ERROR_ERR;\r\n\r\n    peer->pc.cached = 0;\r\n    peer->pc.connection = NULL;\r\n\r\n    rc = ngx_event_connect_peer(&peer->pc);\r\n　　　　//进行相应状态的更新\r\n    if (rc == NGX_ERROR || rc == NGX_DECLINED) {\r\n        ngx_http_upstream_check_status_update(peer, 0);\r\n        return;\r\n    }\r\n\r\n    /* NGX_OK or NGX_AGAIN */\r\n    c = peer->pc.connection;\r\n    c->data = peer;\r\n    c->log = peer->pc.log;\r\n    c->sendfile = 0;\r\n    c->read->log = c->log;\r\n    c->write->log = c->log;\r\n    c->pool = peer->pool;\r\n\r\nupstream_check_connect_done:\r\n    peer->state = NGX_HTTP_CHECK_CONNECT_DONE;\r\n\r\n    c->write->handler = peer->send_handler;\r\n    c->read->handler = peer->recv_handler;\r\n\r\n    ngx_add_timer(&peer->check_timeout_ev, ucscf->check_timeout);\r\n\r\n    /* The kqueue's loop interface needs it. */\r\n    if (rc == NGX_OK) {\r\n        c->write->handler(c->write);\r\n    }\r\n}\r\n```\r\n\r\n相应后端peer的状态的更新\r\n```c\r\nstatic void\r\nngx_http_upstream_check_status_update(ngx_http_upstream_check_peer_t *peer,\r\n    ngx_int_t result)\r\n{\r\n    ngx_http_upstream_check_srv_conf_t  *ucscf;\r\n\r\n    ucscf = peer->conf;\r\n　　　　//后端peer连接成功\r\n    if (result) {\r\n        peer->shm->rise_count++;\r\n        peer->shm->fall_count = 0;\r\n　　　　    //统计累计连续成功的次数　根据配置的rise进行peer的更新\r\n        if (peer->shm->down && peer->shm->rise_count >= ucscf->rise_count) {\r\n            peer->shm->down = 0;\r\n            ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0,\r\n                          \"enable check peer: %V \",\r\n                          &peer->check_peer_addr->name);\r\n        }\r\n    } else {\r\n        //和上面相反操作\r\n        peer->shm->rise_count = 0;\r\n        peer->shm->fall_count++;\r\n        if (!peer->shm->down && peer->shm->fall_count >= ucscf->fall_count) {\r\n            peer->shm->down = 1;\r\n            ngx_log_error(NGX_LOG_ERR, ngx_cycle->log, 0,\r\n                          \"disable check peer: %V \",\r\n                          &peer->check_peer_addr->name);\r\n        }\r\n    }\r\n\r\n    peer->shm->access_time = ngx_current_msec;\r\n}\r\n```\r\n\r\n\r\n\r\n\r\n欢迎一起交流学习 \r\n====\r\n \r\n在使用中有任何问题，欢迎反馈给我，可以用以下联系方式跟我交流\r\n\r\n* 邮件(1031379296#qq.com, 把#换成@)\r\n* QQ: 1031379296\r\n* weibo: [@王发康](http://weibo.com/u/2786211992/home)\r\n\r\n\r\nThx\r\n====\r\n\r\n* chunshengsterATgmail.com\r\n\r\n\r\nAuthor\r\n====\r\n* Linux\\nginx\\golang\\c\\c++爱好者\r\n* 欢迎一起交流  一起学习# \r\n* Others say good and Others good\r\n\r\n\r\n","google":"tengine health check 健康健康模块的分析","note":"Don't delete this file! It's used internally to help with page regeneration."}